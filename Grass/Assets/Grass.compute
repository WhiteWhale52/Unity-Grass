// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#pragma multi_compile_local __ DISTANCE_CULL_ENABLED


struct GrassBlade {

    float3 position;
    //float2 facing;
    float rotAngle;
    float hash;
    float height;
    float width;
    float tilt;
    float bend;
    float3 surfaceNorm;
};

//RWStructuredBuffer<GrassBlade> _GrassBlades;
AppendStructuredBuffer<GrassBlade> _GrassBlades;

uint _Resolution;
float _GrassSpacing;
float _JitterStrength;
float3 _PlaneCentre;
float _GrassBaseHeight = 1;
float _GrassHeightRandom = 0.1;
float _GrassBaseWidth = 2;
float _GrassWidthRandom = 0.011/2;
float _GrassBaseTilt = 0.05;
float _GrassTiltRandom = 0.05/2;
float _GrassBaseBend = 0.01;
float _GrassBendRandom = 0.01;
float _FrustumCullNearOffset;


float _DistanceCullStartDist;
float _DistanceCullEndDist;
float _DistanceCullC;
float _DistanceCullM;
float _DistanceCullMinimumGrassAmount;
float _Test;
float _Test2;
float3 _WSpaceCameraPos;

float4x4 _VP_MATRIX;



Texture2D HeightMap; 
SamplerState samplerHeightMap;
//SamplerState my_linear_mirror_sample;


uint _2DIdTo1D(uint3 id){

    return id.x + id.y * _Resolution;

}


        float2 hashwithoutsine22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}

    float rand(float3 co)
	        {
		        return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
	        }


    float remap01_neg11(float t){
    
        return (t*2)-1;

    }

    uint DistanceCull(float3 worldPos, float hash, float3 norm, float3 posToCam){
    
       

        float viewAngleModulation = pow(saturate(dot(norm, posToCam)  * _DistanceCullC), _Test);

        float viewAngleCull =  hash > (1-viewAngleModulation) ? 1 : -1;


        //Distance culling
        float d = distance(worldPos, _WSpaceCameraPos);

        float distanceSmoothStep = 1-smoothstep(_DistanceCullStartDist, _DistanceCullEndDist, d);

        distanceSmoothStep = (distanceSmoothStep * (1-_DistanceCullMinimumGrassAmount)) + _DistanceCullMinimumGrassAmount;

        //distanceSmoothStep *= viewAngleModulation;


        //float combined = viewAngleCull * _DistanceCullM +(1-distanceSmoothStep);

        return hash > 1-distanceSmoothStep ? 1 : 0;


        //return saturate(viewAngleCull * _DistanceCullM + distanceCull);
        //return distanceCulling > _CullBoundary ? 1 : 0;

        
    }

    uint FrustumCull(float4 clipPos){
    return(clipPos.z > clipPos.w 
    || clipPos.z < - clipPos.w 
    || clipPos.x < - clipPos.w
    || clipPos.x > clipPos.w
    || clipPos.y < - clipPos.w +_FrustumCullNearOffset
    || clipPos.y > clipPos.w)
        ? 0: 1;
}

uint test(float3 pos)
{
    return (pos.x > 5
    || pos.x < -5
    || pos.z>5
    || pos.z<-5)
        ? 0: 1;
}


    float3 getTransformedVertex(float3 vertex){
    

        float2 worldUV = vertex.xz;

        worldUV = worldUV * (1/float2(500,500));

        float height = HeightMap.SampleLevel(samplerHeightMap, worldUV, 0).x;

        vertex.y += height*22.5;

        return vertex;
    
    }

[numthreads(8,8,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!



    if (id.x < _Resolution && id.y < _Resolution){


        float3 position = float3(id.x,0,id.y)*_GrassSpacing - _PlaneCentre;
        
        float2 hash = hashwithoutsine22(id.xy);

        float2 jitter = ((hash*2)-1 ) * _JitterStrength;

        position.xz += jitter;

        float3 bitangent = float3(1, 0, 0);
        float3 tangent   = float3(0, 0, 1);


        float3 vertexBitangent = getTransformedVertex(position + bitangent*0.01);
        float3 vertexTangent = getTransformedVertex(position + tangent*0.01);
        float3 raisedVertex = getTransformedVertex(position);

        float3 newBitangent = (vertexBitangent-raisedVertex ).xyz;
        float3 newTangent = (vertexTangent-raisedVertex).xyz;

        float3 norm = normalize(cross(newTangent,newBitangent));



        

        float4 clipPos = mul(_VP_MATRIX, float4(raisedVertex,1));


        uint isInFrustum = FrustumCull(clipPos);

        uint distanceCull = 1;

        float3 posToCam =  normalize(_WSpaceCameraPos - raisedVertex);

        #if DISTANCE_CULL_ENABLED

            distanceCull = DistanceCull(raisedVertex, hash.x, norm, posToCam);
        #endif


        if (isInFrustum == 1 && distanceCull == 1){

            GrassBlade blade;

            blade.position = raisedVertex;


            float2 bladeFacing = normalize(float2(rand(id.xxy),rand(id.yxx) ) *2 - 1); 


            

            float pi = 3.14159265;



            float d = distance(raisedVertex, _WSpaceCameraPos);

            float s = smoothstep(1.71, 1.71+10, d);

            float viewAlignment = abs(dot(bladeFacing, normalize(posToCam.xz)));


            float orthogonalAngleOffset = smoothstep(_Test2, 0, viewAlignment);

            orthogonalAngleOffset*=s;


            bladeFacing = lerp(bladeFacing,posToCam.xz, orthogonalAngleOffset);

            float grassFacingAngle = atan2(bladeFacing.y,bladeFacing.x);

           

            blade.rotAngle = grassFacingAngle;

            blade.hash = rand(id.xyx);



            blade.height = _GrassBaseHeight + remap01_neg11(  rand(id.xxy) ) * _GrassHeightRandom;


            blade.width = _GrassBaseWidth + remap01_neg11(  rand(id.yxx) ) * _GrassWidthRandom;

            //0-1 value, controlling the vertical component of the p3 point in the bezier curve, horizontal can be derived from pythag.
            blade.tilt = _GrassBaseTilt + remap01_neg11(  rand(id.xyx * float3(1.12, 3.3, 17.6)) ) * _GrassTiltRandom;
            blade.bend = _GrassBaseBend + remap01_neg11(  rand(id.xyy * float3(12.32, 0.23, 3.39)) ) * _GrassBendRandom;

            blade.surfaceNorm = norm;

            //_GrassBlades[_2DIdTo1D(id)] = blade;
            _GrassBlades.Append(blade);

        }

        
    }

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
