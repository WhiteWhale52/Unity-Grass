//#include "UnityCG.cginc"


// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#pragma multi_compile_local __ DISTANCE_CULL_ENABLED


struct GrassBlade {

    float3 position;
    //float2 facing;
    float rotAngle;
    float hash;
    float height;
    float width;
    float tilt;
    float bend;
    float3 surfaceNorm;
    float3 color;
    float windForce;
    float sideBend;
};


struct ClumpParametersStruct {
//Base height : float
//Height random : float
//Base width : float
//Width random : float
//Base tilt : float
//Tilt random : float
//Base bend : float
//Bend random : float
//float4 clumpColor;
//float4 clumpColor;
float pullToCentre;
float pointInSameDirection;
float baseHeight;
float heightRandom;
float baseWidth;
float widthRandom;
float baseTilt;
float tiltRandom;
float baseBend;
float bendRandom;
};

//Texture2D CameraDepthTexture;
//SamplerState MyLinearClampSampler;
//Texture2D<float4> DepthTexture;
//uniform Texture2D<float4> _CameraDepthTexture;
//Texture2D<float4> DepthTexture;


StructuredBuffer<ClumpParametersStruct> _ClumpParameters;

//RWStructuredBuffer<GrassBlade> _GrassBlades;
AppendStructuredBuffer<GrassBlade> _GrassBlades;

uint _Resolution;
float _GrassSpacing;
float _JitterStrength;
float3 _PlaneCentre;
//float _GrassBaseHeight = 1;
//float _GrassHeightRandom = 0.1;
//float _GrassBaseWidth = 2;
//float _GrassWidthRandom = 0.011/2;
//float _GrassBaseTilt = 0.05;
//float _GrassTiltRandom = 0.05/2;
//float _GrassBaseBend = 0.01;
//float _GrassBendRandom = 0.01;

float _FrustumCullNearOffset;
float _FrustumCullEdgeOffset;

float _DistanceCullStartDist;
float _DistanceCullEndDist;
//float _DistanceCullC;
//float _DistanceCullM;
float _DistanceCullMinimumGrassAmount;
float _Test;
float _Test2;
float3 _WSpaceCameraPos;


float4x4 _VP_MATRIX;

Texture2D WindTex; 
SamplerState samplerWindTex;

float _WindControl;
float _BigWindSpeed;
float _BigWindRotateAmount;
float _BigWindScale;
float _SmallWindSpeed;
float _SmallWindScale;
//float _SmallWindRotateAmount;


float4 _Time;

//float4 _ProjectionParams;

Texture2D HeightMap; 
SamplerState samplerHeightMap;

Texture2D ClumpTex; 
SamplerState samplerClumpTex;
float _ClumpScale;
float _NumClumpParameters;

Texture2D ClumpGradientMap; 
SamplerState samplerClumpGradientMap;

//SamplerState my_linear_mirror_sample;


uint _2DIdTo1D(uint3 id){

    return id.x + id.y * _Resolution;

}


        float2 hashwithoutsine22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}

    float rand(float3 co)
	        {
		        return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
	        }


    float remap01_neg11(float t){
    
        return (t*2)-1;

    }

    uint DistanceCull(float3 worldPos, float hash, float3 posToCam){
    
       

        //float viewAngleModulation = pow(saturate(dot(norm, posToCam)  * _DistanceCullC), _Test);

        //float viewAngleCull =  hash > (1-viewAngleModulation) ? 1 : -1;


        //Distance culling
        float d = distance(worldPos, _WSpaceCameraPos);

        float distanceSmoothStep = 1-smoothstep(_DistanceCullStartDist, _DistanceCullEndDist, d);

        distanceSmoothStep = (distanceSmoothStep * (1-_DistanceCullMinimumGrassAmount)) + _DistanceCullMinimumGrassAmount;

        //distanceSmoothStep *= viewAngleModulation;


        //float combined = viewAngleCull * _DistanceCullM +(1-distanceSmoothStep);

        return hash > 1-distanceSmoothStep ? 1 : 0;


        //return saturate(viewAngleCull * _DistanceCullM + distanceCull);
        //return distanceCulling > _CullBoundary ? 1 : 0;

        
    }

    uint FrustumCull(float4 clipPos){
    return(clipPos.z > clipPos.w 
    || clipPos.z < - clipPos.w 
    || clipPos.x < - clipPos.w + _FrustumCullEdgeOffset
    || clipPos.x > clipPos.w - _FrustumCullEdgeOffset
    || clipPos.y < - clipPos.w +_FrustumCullNearOffset
    || clipPos.y > clipPos.w)
        ? 0: 1;
}

uint test(float3 pos)
{
    return (pos.x > 5
    || pos.x < -5
    || pos.z>5
    || pos.z<-5)
        ? 0: 1;
}


    float3 getTransformedVertex(float3 vertex){
    

        float2 worldUV = vertex.xz;

        worldUV = worldUV * (1/float2(500,500));

        float height = HeightMap.SampleLevel(samplerHeightMap, worldUV, 0).x;

        vertex.y += height*22.5;

        return vertex;
    
    }


    float2 rot90CCW(float2 vec){
    
        return float2(-vec.y,vec.x);
    
    }


//  float4 ComputeScreenPos (float4 pos) {
//    float4 o = pos * 0.5f;
//    #if defined(UNITY_HALF_TEXEL_OFFSET)
//    o.xy = float2(o.x, o.y*_ProjectionParams.x) + o.w * _ScreenParams.zw;
//    #else
//    o.xy = float2(o.x, o.y*_ProjectionParams.x) + o.w;
//    #endif
 
//    o.zw = pos.zw;
//    return o;
//}

[numthreads(8,8,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!



    if (id.x < _Resolution && id.y < _Resolution){

        //Calculate xz position
        float3 position = float3(id.x,0,id.y)*_GrassSpacing - _PlaneCentre;
        
        float2 hash = hashwithoutsine22(id.xy);

        //Jitter xz
        float2 jitter = ((hash*2)-1 ) * _JitterStrength;

        position.xz += jitter;

        float2 clumpUV = position.xz * float2(_ClumpScale.xx);

        //Retrieve clump data for this blade from voronoi texture
        //This includes the clump parameter id, and the centre of this clump in texture space
        float3 clumpData = ClumpTex.SampleLevel(samplerClumpTex, clumpUV, 0).xyz;

        //This is the index of the clump parameter set for this blade
        float clumpParamsIndex = clumpData.x*_NumClumpParameters;

        //Retrieve the correct set of blade parameters
        ClumpParametersStruct bladeParameters = _ClumpParameters[int(round(clumpParamsIndex))]; 

        //bladeParameters = _ClumpParameters[2];

        //Compute the clump centre in world space by finding its offsetted position in texture space and -dividing- that by the voronoi tiling 
        float2 clumpCentre = (clumpData.yz + floor(clumpUV))/float2(_ClumpScale.xx);

        //Pull position to centre of clump based on pullToCentre
        position.xz = lerp(position.xz, clumpCentre, bladeParameters.pullToCentre);


        float3 raisedVertex = getTransformedVertex(position);
        float3 posToCam =  normalize(_WSpaceCameraPos - raisedVertex);

        uint distanceCull = 1;
        //Distance culling
        #if DISTANCE_CULL_ENABLED

            distanceCull = DistanceCull(raisedVertex, hash.x, posToCam);
        #endif

        float2 worldUV = position.xz;

        float3 bitangent = float3(1, 0, 0);
        float3 tangent   = float3(0, 0, 1);

        //Get y height from heightmap
        // Also calc surface normal from height map. Probably better to read from a texture
        float3 vertexBitangent = getTransformedVertex(position + bitangent*0.01);
        float3 vertexTangent = getTransformedVertex(position + tangent*0.01);
        

        float3 newBitangent = (vertexBitangent-raisedVertex ).xyz;
        float3 newTangent = (vertexTangent-raisedVertex).xyz;

        float3 norm = normalize(cross(newTangent,newBitangent));



        
        //Get clipPos for easier frustum culling in clip space
        float4 clipPos = mul(_VP_MATRIX, float4(raisedVertex,1));

        //float4 screenPos = ComputeScreenPos(clipPos);
        
        //float2 screenUV = screenPos.xy / screenPos.w;

        //float depth =  CameraDepthTexture.SampleLevel(MyLinearClampSampler, screenUV, 0).x;
        //_DepthTexture[uv.xy];
        //float depth = DepthTexture[float2(0,0)];

        //float depth = 1;

        uint occlusionCull = 1;

        //Frustum culling
        uint isInFrustum = FrustumCull(clipPos);

        

        

        


        if (isInFrustum == 1 && distanceCull == 1 && occlusionCull == 1){
            
            //Copy parameters from parameter struct
            //float4 clumpColor = bladeParameters.clumpColor;
            float baseHeight = bladeParameters.baseHeight;
            float heightRandom = bladeParameters.heightRandom;
            float baseWidth = bladeParameters.baseWidth;
            float widthRandom = bladeParameters.widthRandom;
            float baseTilt = bladeParameters.baseTilt;
            float tiltRandom = bladeParameters.tiltRandom;
            float baseBend = bladeParameters.baseBend;
            float bendRandom = bladeParameters.bendRandom;
            
            //Start building grassblade struct
            GrassBlade blade;



            //float2 positionXZ = lerp(clumpCentre, );

            blade.position = raisedVertex;
            

            

            //float2 bladeFacing = normalize(float2(rand(id.xxy),rand(id.yxx) ) *2 - 1); 

            //Compute the facing by lerping between random facing and shared clump facing based on the pointInSameDirection parameter

            float2 clumpHash = hashwithoutsine22(clumpCentre+float2(0.13, 1.111));

            float2 sharedClumpFacing = normalize( clumpHash  *2 - 1);

            float2 bladeFacing = normalize( hashwithoutsine22(id.xy)  *2 - 1); 

            float2 combinedFacing = normalize(lerp(bladeFacing, sharedClumpFacing, bladeParameters.pointInSameDirection));

            bladeFacing = sharedClumpFacing ;

            float angle = atan2(bladeFacing.y,bladeFacing.x);

            //----Attempt to tilt blades that are orthogonal to camera
            //I think it is better to do this in view space

            //float d = distance(raisedVertex, _WSpaceCameraPos);

            //float s = smoothstep(1.71, 1.71+10, d);

            

            //float viewAlignment = abs(dot(bladeFacing, normalize(posToCam.xz)));

            //float orthogonalAngleOffset = smoothstep(_Test2, 0, viewAlignment);

            //orthogonalAngleOffset*=s;

            //bladeFacing = lerp(bladeFacing,posToCam.xz, orthogonalAngleOffset);

           //float grassFacingAngle = atan2(bladeFacing.y,bladeFacing.x);


                //---Calculate wind, comprised of big wind for overall motion and small wind for smaller details
                

                float2 bigWindUV = worldUV * (_BigWindScale);

                bigWindUV += _Time.y * float2(1,0) *_BigWindSpeed;

                //Alternate method for big wind using same method as small wind
                //float bigWind = (tex2Dlod( _WindTex, float4(bigWindUV.x, bigWindUV.y, 0,0)).x   );
                
                //float bigWind = WindTex.SampleLevel(samplerWindTex, bigWindUV, 0).x*2-1;              

                //float bigWindRotateAngle = (bigWind)* 3.14159 * _BigWindRotateAmount;

                float bigWind = WindTex.SampleLevel(samplerWindTex, bigWindUV, 0).x;

                float bigTheta = ((bigWind*2)-1)* 3.14159;

                float2 bigWindDir = (float2(cos(bigTheta), sin(bigTheta)));

                float2 grassSideVec = normalize(float2(-bladeFacing.y, bladeFacing.x));

                float rotateBladeFromBigWindAmount = dot(grassSideVec, bigWindDir); 

                _BigWindRotateAmount = lerp(0, _BigWindRotateAmount, _WindControl);

                float bigWindRotateAngle = rotateBladeFromBigWindAmount * (3.14159/2) * _BigWindRotateAmount;

                //float2 smallWindUV = worldUV * (_SmallWindScale);

                //smallWindUV += _Time.y * float2(1,0) *_SmallWindSpeed;

                //float smallWind = WindTex.SampleLevel(samplerWindTex, smallWindUV, 0).y;

                //float smallWindRotateAngle = (smallWind)* 3.14159 * _SmallWindRotateAmount;



                //float2 cameraDirXZ = posToCam.xz;

                //float cameraAngle = atan2(cameraDirXZ.y,cameraDirXZ.x);



                angle += bigWindRotateAngle;

                //float2 newFacing = float2(cos(angle), sin(angle));

            blade.rotAngle = angle;
            blade.hash = rand(id.xyx);


            

            //READ FROM CLUMP PARAMETERS

                        //float baseHeight = _ClumpParameters[0].baseHeight;
            //float heightRandom = _ClumpParameters[0].heightRandom;
            //float baseWidth = _ClumpParameters[0].baseWidth;
            //float widthRandom = _ClumpParameters[0].widthRandom;
            //float baseTilt = _ClumpParameters[0].baseTilt;
            //float tiltRandom = _ClumpParameters[0].tiltRandom;
            //float baseBend = _ClumpParameters[0].baseBend;
            //float bendRandom = _ClumpParameters[0].bendRandom;
            //float baseHeight = _ClumpParameters[1].baseHeight;
            //float heightRandom = _ClumpParameters[1].heightRandom;
            //float baseWidth = _ClumpParameters[1].baseWidth;
            //float widthRandom = _ClumpParameters[1].widthRandom;
            //float baseTilt = _ClumpParameters[1].baseTilt;
            //float tiltRandom = _ClumpParameters[1].tiltRandom;
            //float baseBend = _ClumpParameters[1].baseBend;
            //float bendRandom = _ClumpParameters[1].bendRandom;

            blade.height = baseHeight + remap01_neg11(  rand(id.xxy) ) * heightRandom;
            blade.width = baseWidth + remap01_neg11(  rand(id.yxx) ) * widthRandom;
            //0-1 value, controlling the vertical component of the p3 point in the bezier curve, horizontal can be derived from pythag.
            blade.tilt = baseTilt + remap01_neg11(  rand(id.xyx * float3(1.12, 3.3, 17.6)) ) * tiltRandom;
            blade.bend = baseBend + remap01_neg11(  rand(id.xyy * float3(12.32, 0.23, 3.39)) ) * bendRandom;

            //blade.height = _GrassBaseHeight + remap01_neg11(  rand(id.xxy) ) * _GrassHeightRandom;
            //blade.width = _GrassBaseWidth + remap01_neg11(  rand(id.yxx) ) * _GrassWidthRandom;
            ////0-1 value, controlling the vertical component of the p3 point in the bezier curve, horizontal can be derived from pythag.
            //blade.tilt = _GrassBaseTilt + remap01_neg11(  rand(id.xyx * float3(1.12, 3.3, 17.6)) ) * _GrassTiltRandom;
            //blade.bend = _GrassBaseBend + remap01_neg11(  rand(id.xyy * float3(12.32, 0.23, 3.39)) ) * _GrassBendRandom;
            blade.surfaceNorm = norm;
            //blade.color = clumpParamsIndex.xxx;

            float3 clumpColor =  ClumpGradientMap.SampleLevel(samplerClumpGradientMap, clumpHash.x, 0).xyz;

            blade.color = clumpColor.xyz;


            
            float viewAlignment = abs(dot(bladeFacing, normalize(posToCam.xz)));
            float sideBend = smoothstep(_Test, 0, viewAlignment)*_Test2;
            //float sideBend = viewAlignment < _Test  ? _Test2 : 0;
            

            blade.sideBend = sideBend;

            blade.windForce = (bigWind);
            //blade.windForce = (1+1)/2;
            //_GrassBlades[_2DIdTo1D(id)] = blade;
            _GrassBlades.Append(blade);

        }

        
    }

}
