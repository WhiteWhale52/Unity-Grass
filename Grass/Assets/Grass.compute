// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main



struct GrassBlade {

    float3 position;
    float2 facing;
    float hash;
    float height;
    float width;
    float tilt;
    float bend;
    
};

RWStructuredBuffer<GrassBlade> _GrassBlades;

uint _Resolution;
float _GrassSpacing;
float _JitterStrength;
float3 _PlaneCentre;
float _GrassBaseHeight = 1;
float _GrassHeightRandom = 0.1;
float _GrassBaseWidth = 2;
float _GrassWidthRandom = 0.011/2;
float _GrassBaseTilt = 0.05;
float _GrassTiltRandom = 0.05/2;
float _GrassBaseBend = 0.01;
float _GrassBendRandom = 0.01;

Texture2D HeightMap; 
SamplerState samplerHeightMap;

uint _2DIdTo1D(uint3 id){

    return id.x + id.y * _Resolution;

}

//float float rand(float2 co)
//{
//    float a = 12.9898;
//    float b = 78.233;
//    float c = 43758.5453;
//    float dt= dot(co.xy ,vec2(a,b));
//    float sn= mod(dt,3.14);
//    return fract(sin(sn) * c);
//}

/*
Output properties:
float3 position
float2 facing
float hash
float Height (sample from texture?)
float width
float tilt
float bend

*/

        float2 hashwithoutsine22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}

    float rand(float3 co)
	        {
		        return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
	        }


    float remap01_neg11(float t){
    
        return (t*2)-1;

    }


[numthreads(8,8,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!



    if (id.x < _Resolution && id.y < _Resolution){

        //float3 planeOffset = float3(_PlaneCentre.x, 0, _PlaneCentre.z);


        float3 position = float3(id.x,0,id.y)*_GrassSpacing - _PlaneCentre;

        float2 jitter = ((hashwithoutsine22(id.xy)*2)-1 ) * _JitterStrength;
        //float jitterY = rand(id.y,0,id.x);

        position.xz += jitter;

        float2 worldUV = position.xz;

        worldUV = worldUV * (1/float2(500,500));

        float height = HeightMap.SampleLevel(samplerHeightMap, worldUV, 0).x;

        position.y += height*40.6;

        GrassBlade blade;

        blade.position = position;

        blade.facing = float2(rand(id.xxy),rand(id.yxx) ) *2 - 1;

        //blade.facing = normalize(hashwithoutsine22(id.yx));
        //blade.facing = float2(1,0);
        blade.hash = rand(id.xyx);
        blade.height = _GrassBaseHeight + remap01_neg11(  rand(id.xxy) ) * _GrassHeightRandom;
        blade.width = _GrassBaseWidth + remap01_neg11(  rand(id.yxx) ) * _GrassWidthRandom;
        //blade.width = _GrassBaseWidth;
        //blade.width = 2;
        //0-1 value, controlling the vertical component of the p3 point in the bezier curve, horizontal can be derived from pythag.
        blade.tilt = _GrassBaseTilt + remap01_neg11(  rand(id.xyx * float3(1.12, 3.3, 17.6)) ) * _GrassTiltRandom;
        blade.bend = _GrassBaseBend + remap01_neg11(  rand(id.xyy * float3(12.32, 0.23, 3.39)) ) * _GrassBendRandom;


        _GrassBlades[_2DIdTo1D(id)] = blade;
    }

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
